<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>米格 的 盒子</title>
    <style>
        :root{
            --bg:#f1f5f9;
            --card:#ffffff;
            --accent:#e53935;
            --muted:#6b7280;
            --primary:#2b8cff;
            --success:#27ae60;
            --text:#111827;
        }
        html, body {
            height:100%;
            margin:0;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
            background: var(--bg);
            display:flex;
            align-items:center;
            justify-content:center;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
            color:var(--text);
            padding:24px;
        }
        .app {
            width: min(780px, 96%);
            max-width: 920px;
            background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.9));
            border-radius:14px;
            box-shadow: 0 8px 30px rgba(16,24,40,0.08);
            padding:18px;
        }
        .header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            margin-bottom:12px;
        }
        .title {
            font-size:18px;
            font-weight:700;
            color:var(--text);
        }
        .controls {
            display:flex;
            gap:10px;
            align-items:center;
        }
        .status {
            font-size:15px;
            color:var(--muted);
        }
        .btn {
            padding:8px 12px;
            background:var(--card);
            border-radius:8px;
            border:1px solid rgba(16,24,40,0.06);
            cursor:pointer;
            font-weight:600;
            color:var(--text);
        }
        .btn.primary {
            background:var(--primary);
            color:#fff;
            border-color:transparent;
        }
        .scene {
            display:flex;
            align-items:center;
            justify-content:center;
            gap:18px;
            padding:12px;
        }
        .board-wrap {
            width:520px;
            max-width:100%;
            background:transparent;
            display:block;
        }
        svg { width:100%; height:auto; display:block; }
        /* node/mark styles */
        .node-area { transition: all .12s ease; }
        .node-area.possible { fill: rgba(43,140,255,0.10); stroke:var(--primary); stroke-width:3; }
        .mark.selected { stroke:#f1c40f; filter: drop-shadow(0 6px 10px rgba(0,0,0,0.12)); transform-origin:center; }
        .mark { stroke:#111827; }
        .win { stroke:var(--success) !important; filter: drop-shadow(0 6px 14px rgba(39,174,96,0.18)); }
        .node-label { font-size:12px; fill:var(--muted); text-anchor:middle; dominant-baseline:hanging; pointer-events:none; user-select:none; }
        /* responsive */
        @media (max-width:560px){
            .board-wrap { width:100%; }
            .title { font-size:16px; }
        }
        /* mobile adjustments */
        @media (max-width:420px){
            .app { padding:12px; border-radius:12px; }
            .header { flex-direction:column; align-items:flex-start; gap:8px; }
            .controls { width:100%; justify-content:space-between; }
            .status { font-size:14px; }
            .btn { padding:10px 14px; font-size:15px; border-radius:10px; }
            .board-wrap { width:100%; }
            .node-label { font-size:11px; }
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="header">
            <div class="title">三子连线 — 米字棋盘</div>
            <div class="controls">
                <div id="status" class="status">轮到: <strong id="turn">X</strong></div>
                <button id="resetBtn" class="btn">重置</button>
                <button id="aiBtn" class="btn">AI: 关</button>
            </div>
        </div>

        <div class="scene">
            <div class="board-wrap">
                <svg id="board" viewBox="0 0 420 320" xmlns="http://www.w3.org/2000/svg" class="container" aria-label="三子连线 米字形 棋盘">
            <defs>
                <style>
                    .sketch {
                        fill: none;
                        stroke: #e53935;
                        stroke-width: 6;
                        stroke-linecap: round;
                        stroke-linejoin: round;
                        vector-effect: non-scaling-stroke;
                    }
                    .node-area { fill: transparent; cursor: pointer; pointer-events: all; }
                    #marks { pointer-events: none; }
                    .node-area.possible { fill: rgba(43,140,255,0.08); stroke:#2b8cff; stroke-width:3; }
                    .mark { stroke:#222; stroke-width:6; stroke-linecap:round; stroke-linejoin:round; pointer-events: none; }
                    .mark.selected { stroke:#f1c40f; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.12)); }
                    .mark circle { fill: none; }
                    .win { stroke:#27ae60 !important; }
                    .node-label { font-size:12px; fill:#666; text-anchor:middle; dominant-baseline:hanging; pointer-events:none; user-select:none; }
                </style>
            </defs>

            <!-- 米 字 线条（背景）：两条对角线 + 中心水平 + 中心垂直 -->
            <rect x="12" y="12" width="396" height="296" class="sketch" />
            <!-- 对角线 TL -> BR -->
            <line class="sketch" x1="18" y1="18" x2="402" y2="298" />
            <!-- 对角线 TR -> BL -->
            <line class="sketch" x1="402" y1="18" x2="18" y2="298" />
            <!-- 水平中线 -->
            <line class="sketch" x1="18" y1="160" x2="402" y2="160" />
            <!-- 垂直中线 -->
            <line class="sketch" x1="210" y1="18" x2="210" y2="302" />

            <!-- 9 节点（3x3）中心点，便于三子连线规则与点击 -->
            <!-- indices: 0..8 left->right, top->bottom -->
            <g id="nodes">
                <circle class="node-area" data-index="0" cx="60" cy="60" r="28"></circle>
                <text class="node-label" x="60" y="86">1</text>
                <circle class="node-area" data-index="1" cx="210" cy="60" r="28"></circle>
                <text class="node-label" x="210" y="86">2</text>
                <circle class="node-area" data-index="2" cx="360" cy="60" r="28"></circle>
                <text class="node-label" x="360" y="86">3</text>

                <circle class="node-area" data-index="3" cx="60" cy="160" r="28"></circle>
                <text class="node-label" x="60" y="186">4</text>
                <circle class="node-area" data-index="4" cx="210" cy="160" r="28"></circle>
                <text class="node-label" x="210" y="186">5</text>
                <circle class="node-area" data-index="5" cx="360" cy="160" r="28"></circle>
                <text class="node-label" x="360" y="186">6</text>

                <circle class="node-area" data-index="6" cx="60" cy="260" r="28"></circle>
                <text class="node-label" x="60" y="286">7</text>
                <circle class="node-area" data-index="7" cx="210" cy="260" r="28"></circle>
                <text class="node-label" x="210" y="286">8</text>
                <circle class="node-area" data-index="8" cx="360" cy="260" r="28"></circle>
                <text class="node-label" x="360" y="286">9</text>
            </g>

            <!-- container for marks -->
            <g id="marks"></g>
        </svg>
    </div>

    <script>
        (function(){
            // Lines for win detection: only the 米字 (center vertical, center horizontal, two diagonals)
            const winLines = [
                [3,4,5], // horizontal middle
                [1,4,7], // vertical middle
                [0,4,8], // diagonal TL-BR
                [2,4,6]  // diagonal TR-BL
            ];
            // Lines along which movement is allowed: any straight line through the grid
            // (rows, columns, both main diagonals)
            const moveLines = [
                [0,1,2],
                [3,4,5],
                [6,7,8],
                [0,3,6],
                [1,4,7],
                [2,5,8],
                [0,4,8],
                [2,4,6]
            ];

            // initial setup: X on top row, O on bottom row
            const initialBoard = ['X','X','X', null, null, null, 'O','O','O'];
            const board = initialBoard.slice();
            let turn = 'X';
            let winner = null;
            let selected = null; // index of selected piece to move

            const svg = document.getElementById('board');
            const marksGroup = document.getElementById('marks');
            const nodes = Array.from(document.querySelectorAll('.node-area'));
            const turnEl = document.getElementById('turn');
            const statusEl = document.getElementById('status');
            const resetBtn = document.getElementById('resetBtn');
            const aiBtn = document.getElementById('aiBtn');
            let aiEnabled = false;
            const aiSide = 'O';
            // mobile: adjust node hit size and UI for touch
            function adjustForMobile(){
                const isMobile = window.innerWidth <= 420 || /Mobi|Android/i.test(navigator.userAgent);
                nodes.forEach(n => {
                    // increase clickable radius on mobile
                    const r = isMobile ? 38 : 28;
                    n.setAttribute('r', r);
                });
                // increase mark stroke for visibility
                Array.from(document.querySelectorAll('.mark')).forEach(m => {
                    m.style.strokeWidth = isMobile ? '8' : '6';
                });
                // update control sizes
                const btns = Array.from(document.querySelectorAll('.btn'));
                btns.forEach(b => {
                    if (isMobile) b.style.padding = '10px 14px';
                    else b.style.padding = '';
                });
            }
            window.addEventListener('resize', adjustForMobile);

            // movement rule:
            // compute allowed targets dynamically at each move:
            // for the selected node, gather every straight line (rows/cols/diagonals in moveLines) that contains it,
            // then any empty node on those lines is a valid target (no blocking checks).
            function getAllowedTargets(sel){
                if (sel === null) return [];
                const allowed = new Set();
                for (const line of moveLines){
                    const pos = line.indexOf(sel);
                    if (pos === -1) continue;
                    for (let j = 0; j < line.length; j++){
                        const idx = line[j];
                        if (idx === sel) continue;
                        // target must be empty
                        if (board[idx] !== null) continue;
                        // check intermediate nodes between pos and j; if any occupied => blocked
                        const start = Math.min(pos, j) + 1;
                        const end = Math.max(pos, j) - 1;
                        let blocked = false;
                        for (let k = start; k <= end; k++){
                            const midIdx = line[k];
                            if (board[midIdx] !== null) { blocked = true; break; }
                        }
                        if (!blocked) allowed.add(idx);
                    }
                }
                return Array.from(allowed);
            }

            // draw all marks based on board state
            function drawAllMarks(){
                while (marksGroup.firstChild) marksGroup.removeChild(marksGroup.firstChild);
                board.forEach((val,i)=>{
                    if (val) drawMarkAt(i, val);
                });
                updateSelectionVisual();
            }

            function handleNodeClick(i){
                console.debug('click node', i, 'selected=', selected, 'turn=', turn, 'cell=', board[i], 'board=', board);
                if (winner) return;
                const cell = board[i];
                // clicking own piece -> select/deselect
                if (cell === turn){
                    if (selected === i){
                        selected = null;
                    } else {
                        selected = i;
                    }
                    updateSelectionVisual();
                    return;
                }

                // clicking empty and have selected piece -> attempt move (must be adjacent along 米 lines)
                if (cell === null && selected !== null){
                    const allowed = getAllowedTargets(selected);
                    console.debug('allowed targets for', selected, allowed);
                    if (!allowed.includes(i)) {
                        // not allowed move
                        // brief visual feedback: flash possible nodes
                        flashInvalid();
                        return;
                    }
                    // perform move
                    board[selected] = null;
                    board[i] = turn;
                    selected = null;
                    drawAllMarks();
                    const w = checkWin();
                    if (w){
                        winner = turn;
                        highlightWin(w);
                        statusEl.innerHTML = '胜利: <strong>' + winner + '</strong>';
                        return;
                    }
                    if (board.every(v=>v!==null)){
                        statusEl.textContent = '平局';
                        return;
                    }
                    // switch turn
                    turn = turn === 'X' ? 'O' : 'X';
                    turnEl.textContent = turn;
                    statusEl.innerHTML = '轮到: <strong id="turn">' + turn + '</strong>';
                    // if AI is enabled and it's AI's turn, trigger AI move
                    if (aiEnabled && turn === aiSide && !winner){
                        setTimeout(aiMove, 300);
                    }
                }
            }

            function drawMarkAt(i, symbol){
                const node = nodes[i];
                const cx = parseFloat(node.getAttribute('cx'));
                const cy = parseFloat(node.getAttribute('cy'));
                const g = document.createElementNS('http://www.w3.org/2000/svg','g');
                g.setAttribute('data-i', i);
                g.classList.add('mark');
                if (symbol === 'X'){
                    const l1 = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l1.setAttribute('x1', cx-12); l1.setAttribute('y1', cy-12);
                    l1.setAttribute('x2', cx+12); l1.setAttribute('y2', cy+12);
                    const l2 = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l2.setAttribute('x1', cx+12); l2.setAttribute('y1', cy-12);
                    l2.setAttribute('x2', cx-12); l2.setAttribute('y2', cy+12);
                    g.appendChild(l1); g.appendChild(l2);
                } else {
                    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
                    c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 12);
                    c.setAttribute('fill', 'none');
                    g.appendChild(c);
                }
                marksGroup.appendChild(g);
            }

            function checkWin(){
                for (const line of winLines){
                    const [a,b,c] = line;
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) return line;
                }
                return null;
            }

            // check win on an arbitrary board array (used for AI simulation)
            function checkWinFor(boardArr){
                for (const line of winLines){
                    const [a,b,c] = line;
                    if (boardArr[a] && boardArr[a] === boardArr[b] && boardArr[a] === boardArr[c]) return line;
                }
                return null;
            }

            function highlightWin(line){
                for (const idx of line){
                    const mark = marksGroup.querySelector('[data-i="'+idx+'"]');
                    if (mark) mark.classList.add('win');
                }
            }

            function updateSelectionVisual(){
                // remove previous selection classes
                Array.from(marksGroup.querySelectorAll('.mark')).forEach(m => m.classList.remove('selected'));
                Array.from(document.querySelectorAll('.node-area')).forEach(n => n.classList.remove('possible'));
                if (selected !== null){
                    const sel = marksGroup.querySelector('[data-i="'+selected+'"]');
                    if (sel) sel.classList.add('selected');
                    // highlight possible targets based on line rules
                    const allowed = getAllowedTargets(selected);
                    allowed.forEach(idx=>{
                        const nodeEl = document.querySelector('.node-area[data-index="'+idx+'"]');
                        if (nodeEl) nodeEl.classList.add('possible');
                    });
                }
            }

            function flashInvalid(){
                // briefly flash the board to indicate invalid move
                svg.style.transition = 'transform .06s';
                svg.style.transform = 'translateX(6px)';
                setTimeout(()=>{ svg.style.transform='translateX(-6px)'; }, 60);
                setTimeout(()=>{ svg.style.transform=''; svg.style.transition=''; }, 180);
            }

            // --- AI logic ---
            function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

            function aiMove(){
                if (!aiEnabled || winner) return;
                // simple AI: try win, then block, else random legal move
                const ai = aiSide;
                const human = ai === 'X' ? 'O' : 'X';
                // gather all AI pieces and their allowed targets
                const pieces = [];
                for (let i=0;i<board.length;i++){
                    if (board[i] === ai) pieces.push(i);
                }
                // build possible moves [piece,target]
                const moves = [];
                for (const p of pieces){
                    const targets = getAllowedTargets(p);
                    for (const t of targets) moves.push([p,t]);
                }
                if (moves.length === 0){
                    statusEl.textContent = 'AI 无可走步，跳过';
                    // switch back
                    turn = human;
                    turnEl.textContent = turn;
                    return;
                }

                // try winning move
                for (const [p,t] of moves){
                    const copy = board.slice();
                    copy[p] = null;
                    copy[t] = ai;
                    if (checkWinFor(copy)){
                        performAIMove(p,t);
                        return;
                    }
                }
                // try block opponent immediate win: see if human has winning move now, and try to occupy that target
                const humanThreats = new Set();
                for (let hp=0; hp<board.length; hp++){
                    if (board[hp] !== human) continue;
                    const ht = getAllowedTargets(hp);
                    for (const t of ht){
                        const copy = board.slice();
                        copy[hp] = null;
                        copy[t] = human;
                        if (checkWinFor(copy)) humanThreats.add(t);
                    }
                }
                if (humanThreats.size){
                    // try to move to any threatened target
                    for (const [p,t] of moves){
                        if (humanThreats.has(t)){
                            performAIMove(p,t);
                            return;
                        }
                    }
                }
                // fallback: random move among moves
                const [p,t] = pickRandom(moves);
                performAIMove(p,t);
            }

            function performAIMove(p,t){
                // small delay to show thinking
                svg.style.pointerEvents = 'none';
                statusEl.textContent = 'AI 思考中...';
                setTimeout(()=>{
                    board[p] = null;
                    board[t] = aiSide;
                    drawAllMarks();
                    const w = checkWin();
                    if (w){
                        winner = aiSide;
                        highlightWin(w);
                        statusEl.innerHTML = '胜利: <strong>' + winner + '</strong>';
                    } else {
                        // switch turn back to human
                        turn = turn === 'X' ? 'O' : 'X';
                        turnEl.textContent = turn;
                        statusEl.innerHTML = '轮到: <strong id="turn">' + turn + '</strong>';
                    }
                    svg.style.pointerEvents = '';
                }, 420);
            }

            aiBtn.addEventListener('click', ()=>{
                aiEnabled = !aiEnabled;
                aiBtn.textContent = 'AI: ' + (aiEnabled ? '开' : '关');
                // if enabling and it's AI's turn, trigger move
                if (aiEnabled && turn === aiSide && !winner){
                    setTimeout(aiMove, 300);
                }
            });

            function reset(){
                // restore initial configuration: top row X, bottom row O
                for (let i=0;i<9;i++) board[i] = initialBoard[i];
                turn = 'X';
                winner = null;
                selected = null;
                turnEl.textContent = turn;
                statusEl.innerHTML = '轮到: <strong id="turn">X</strong>';
                drawAllMarks();
                if (aiEnabled && turn === aiSide){
                    setTimeout(aiMove, 300);
                }
            }

            // initialize
            nodes.forEach(n=> n.addEventListener('click', ()=> handleNodeClick(parseInt(n.getAttribute('data-index'),10))));
            resetBtn.addEventListener('click', reset);
            drawAllMarks();
            // call mobile adjust once after draw
            adjustForMobile();

            window.miGame = { board, reset };
        })();
    </script>
</body>

</html>