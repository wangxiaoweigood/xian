<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>米格 的 盒子</title>
    <style>
        :root{
            --bg:#f6f9fc;
            --card:#ffffff;
            --accent:#e53935;
            --muted:#6b7280;
            --primary:#1e88ff;
            --success:#27ae60;
            --text:#0f1724;
            --glass: rgba(255,255,255,0.7);
        }
        html, body {
            height:100%;
            margin:0;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
            background: var(--bg);
            display:flex;
            align-items:center;
            justify-content:center;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
            color:var(--text);
            padding:24px;
        }
        .app {
            width: min(780px, 96%);
            max-width: 920px;
            background: linear-gradient(180deg, var(--glass), rgba(255,255,255,0.95));
            border-radius:14px;
            box-shadow: 0 10px 30px rgba(16,24,40,0.08);
            padding:18px;
            border: 1px solid rgba(16,24,40,0.04);
        }
        .header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            margin-bottom:12px;
            gap:12px;
        }
        .title {
            font-size:20px;
            font-weight:800;
            color:var(--text);
            letter-spacing:0.2px;
        }
        .controls {
            display:flex;
            gap:10px;
            align-items:center;
        }
        .status {
            font-size:14px;
            color:var(--muted);
            background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(255,255,255,0.2));
            padding:6px 10px;
            border-radius:8px;
            border:1px solid rgba(16,24,40,0.03);
        }
        .btn {
            padding:8px 12px;
            background:var(--card);
            border-radius:10px;
            border:1px solid rgba(16,24,40,0.06);
            cursor:pointer;
            font-weight:700;
            color:var(--text);
            transition: all .16s ease;
            box-shadow: 0 2px 6px rgba(16,24,40,0.04);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(16,24,40,0.08); }
        .btn.primary {
            background:var(--primary);
            color:#fff;
            border-color:transparent;
            box-shadow: 0 6px 20px rgba(30,136,255,0.18);
        }
        .scene {
            display:flex;
            align-items:center;
            justify-content:center;
            gap:18px;
            padding:12px;
        }
        .board-wrap {
            width:520px;
            max-width:100%;
            background:transparent;
            display:block;
        }
        svg { width:100%; height:auto; display:block; }
        /* node/mark styles */
        .node-area { transition: all .12s ease; }
        .node-area:hover { fill: rgba(30,136,255,0.06); }
        .node-area.possible { fill: rgba(30,136,255,0.12); stroke:var(--primary); stroke-width:3; }
        .mark.selected { stroke:#f1c40f; filter: drop-shadow(0 6px 10px rgba(0,0,0,0.12)); transform-origin:center; transform: scale(1.02); }
        .mark { stroke:#0f1724; }
        .mark line { stroke-linecap:round; stroke-linejoin:round; }
        .mark circle { stroke:var(--primary); stroke-width:6; fill:none; }
        .win { stroke:var(--success) !important; filter: drop-shadow(0 6px 14px rgba(39,174,96,0.18)); }
        .node-label { font-size:12px; fill:var(--muted); text-anchor:middle; dominant-baseline:hanging; pointer-events:none; user-select:none; }
        /* responsive */
        @media (max-width:560px){
            .board-wrap { width:100%; }
            .title { font-size:16px; }
        }
        /* mobile adjustments */
        @media (max-width:420px){
            .app { padding:12px; border-radius:12px; }
            .header { flex-direction:column; align-items:stretch; gap:10px; }
            .controls { display:flex; flex-direction:column; gap:10px; align-items:stretch; width:100%; }
            .controls > * { width:100%; }
            .status { font-size:14px; padding:8px 10px; text-align:left; }
            .btn { padding:12px 14px; font-size:15px; border-radius:10px; width:100%; }
            .board-wrap { width:100%; margin-top:6px; }
            .node-label { font-size:11px; }
            /* make color pickers align neatly on mobile */
            .controls input[type="color"]{ width:44px; height:36px; padding:0; }
            .controls div { display:flex; gap:8px; align-items:center; justify-content:flex-start; flex-wrap:wrap; }
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="header">
            <div class="title">三子连线 — 米字棋盘</div>
            <div class="controls">
                <div id="status" class="status">轮到: <strong id="turn">X</strong></div>
                <button id="resetBtn" class="btn">重置</button>
                <button id="aiBtn" class="btn">AI: 关</button>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label for="accentPicker" style="font-size:12px;color:var(--muted);">线色</label>
                    <input id="accentPicker" type="color" title="米字线颜色" style="width:36px;height:36px;border-radius:8px;border:0;padding:0"/>
                    <label for="primaryPicker" style="font-size:12px;color:var(--muted);margin-left:6px;">高亮</label>
                    <input id="primaryPicker" type="color" title="高亮/圈色" style="width:36px;height:36px;border-radius:8px;border:0;padding:0"/>
                </div>
            </div>
        </div>

        <div class="scene">
            <div class="board-wrap">
                <svg id="board" viewBox="0 0 420 320" xmlns="http://www.w3.org/2000/svg" class="container" aria-label="三子连线 米字形 棋盘">
            <defs>
                <style>
                    .sketch {
                        fill: none;
                        stroke: var(--accent);
                        stroke-width: 10;
                        stroke-linecap: round;
                        stroke-linejoin: round;
                        vector-effect:non-scaling-stroke;
                        opacity:0.98;
                    }
                    .node-area { fill: transparent; cursor: pointer; pointer-events: all; transition: fill .12s ease; }
                    #marks { pointer-events: none; }
                    .node-area.possible { fill: rgba(30,136,255,0.12); stroke:var(--primary); stroke-width:3; }
                    .mark { stroke:var(--text); stroke-width:8; stroke-linecap:round; stroke-linejoin:round; pointer-events: none; }
                    .mark.selected { stroke:#f1c40f; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.12)); transform-origin:center; }
                    .mark circle { fill: none; stroke:var(--primary); stroke-width:6; }
                    .win { stroke:var(--success) !important; }
                    .node-label { font-size:12px; fill:var(--muted); text-anchor:middle; dominant-baseline:hanging; pointer-events:none; user-select:none; }
                </style>
            </defs>

            <!-- 米 字 线条（背景）：两条对角线 + 中心水平 + 中心垂直 -->
            <rect x="12" y="12" width="396" height="296" class="sketch" />
            <!-- 对角线 TL -> BR -->
            <line class="sketch" x1="18" y1="18" x2="402" y2="298" />
            <!-- 对角线 TR -> BL -->
            <line class="sketch" x1="402" y1="18" x2="18" y2="298" />
            <!-- 水平中线 -->
            <line class="sketch" x1="18" y1="160" x2="402" y2="160" />
            <!-- 垂直中线 -->
            <line class="sketch" x1="210" y1="18" x2="210" y2="302" />

            <!-- 9 节点（3x3）中心点，便于三子连线规则与点击 -->
            <!-- indices: 0..8 left->right, top->bottom -->
            <g id="nodes">
                <circle class="node-area" data-index="0" cx="36" cy="40" r="28"></circle>
                <text class="node-label" x="36" y="66">1</text>
                <circle class="node-area" data-index="1" cx="210" cy="40" r="28"></circle>
                <text class="node-label" x="210" y="66">2</text>
                <circle class="node-area" data-index="2" cx="384" cy="40" r="28"></circle>
                <text class="node-label" x="384" y="66">3</text>

                <circle class="node-area" data-index="3" cx="36" cy="160" r="28"></circle>
                <text class="node-label" x="36" y="186">4</text>
                <circle class="node-area" data-index="4" cx="210" cy="160" r="28"></circle>
                <text class="node-label" x="210" y="186">5</text>
                <circle class="node-area" data-index="5" cx="384" cy="160" r="28"></circle>
                <text class="node-label" x="384" y="186">6</text>

                <circle class="node-area" data-index="6" cx="36" cy="280" r="28"></circle>
                <text class="node-label" x="36" y="306">7</text>
                <circle class="node-area" data-index="7" cx="210" cy="280" r="28"></circle>
                <text class="node-label" x="210" y="306">8</text>
                <circle class="node-area" data-index="8" cx="384" cy="280" r="28"></circle>
                <text class="node-label" x="384" y="306">9</text>
            </g>

            <!-- container for marks -->
            <g id="marks"></g>
        </svg>
    </div>

    <script>
        (function(){
            // Lines for win detection: only the 米字 (center vertical, center horizontal, two diagonals)
            const winLines = [
                [3,4,5], // horizontal middle
                [1,4,7], // vertical middle
                [0,4,8], // diagonal TL-BR
                [2,4,6]  // diagonal TR-BL
            ];
            // Lines along which movement is allowed: rows, columns and the two main diagonals
            const moveLines = [
                [0,1,2],
                [3,4,5],
                [6,7,8],
                [0,3,6],
                [1,4,7],
                [2,5,8],
                [0,4,8],
                [2,4,6]
            ];

            // initial setup: X on top row, O on bottom row
            const initialBoard = ['X','X','X', null, null, null, 'O','O','O'];
            const board = initialBoard.slice();
            let turn = 'X';
            let winner = null;
            let selected = null; // index of selected piece to move

            const svg = document.getElementById('board');
            const marksGroup = document.getElementById('marks');
            const nodes = Array.from(document.querySelectorAll('.node-area'));
            const turnEl = document.getElementById('turn');
            const statusEl = document.getElementById('status');
            const resetBtn = document.getElementById('resetBtn');
            const aiBtn = document.getElementById('aiBtn');
            let aiEnabled = false;
            const aiSide = 'O';
            // mobile: adjust node hit size and UI for touch
            function adjustForMobile(){
                const isMobile = window.innerWidth <= 420 || /Mobi|Android/i.test(navigator.userAgent);
                nodes.forEach(n => {
                    // increase clickable radius on mobile
                    const r = isMobile ? 38 : 28;
                    n.setAttribute('r', r);
                });
                // increase mark stroke for visibility
                Array.from(document.querySelectorAll('.mark')).forEach(m => {
                    m.style.strokeWidth = isMobile ? '8' : '6';
                });
                // update control sizes
                const btns = Array.from(document.querySelectorAll('.btn'));
                btns.forEach(b => {
                    if (isMobile) b.style.padding = '10px 14px';
                    else b.style.padding = '';
                });
            }
            window.addEventListener('resize', adjustForMobile);

            // movement rule:
            // compute allowed targets dynamically at each move:
            // for the selected node, gather every straight line (rows/cols/diagonals in moveLines) that contains it,
            // then any empty node on those lines is a valid target (no blocking checks).
            function getAllowedTargets(sel){
                // Only allow moving one step along any allowed line (no multi-step moves).
                if (sel === null) return [];
                const allowed = new Set();
                for (const line of moveLines){
                    const pos = line.indexOf(sel);
                    if (pos === -1) continue;
                    // neighbor positions are pos-1 and pos+1 if within bounds
                    const neighbors = [];
                    if (pos - 1 >= 0) neighbors.push(line[pos - 1]);
                    if (pos + 1 < line.length) neighbors.push(line[pos + 1]);
                    for (const idx of neighbors){
                        if (board[idx] === null) allowed.add(idx);
                    }
                }
                return Array.from(allowed);
            }

            // draw all marks based on board state
            function drawAllMarks(){
                while (marksGroup.firstChild) marksGroup.removeChild(marksGroup.firstChild);
                board.forEach((val,i)=>{
                    if (val) drawMarkAt(i, val);
                });
                updateSelectionVisual();
            }

            function handleNodeClick(i){
                console.debug('click node', i, 'selected=', selected, 'turn=', turn, 'cell=', board[i], 'board=', board);
                if (winner) return;
                const cell = board[i];
                // clicking own piece -> select/deselect
                if (cell === turn){
                    if (selected === i){
                        selected = null;
                    } else {
                        selected = i;
                    }
                    updateSelectionVisual();
                    return;
                }

                // clicking empty and have selected piece -> attempt move (must be adjacent along 米 lines)
                if (cell === null && selected !== null){
                    const allowed = getAllowedTargets(selected);
                    console.debug('allowed targets for', selected, allowed);
                    if (!allowed.includes(i)) {
                        // not allowed move
                        // brief visual feedback: flash possible nodes
                        flashInvalid();
                        return;
                    }
                    // perform move
                    board[selected] = null;
                    board[i] = turn;
                    selected = null;
                    drawAllMarks();
                    const w = checkWin();
                    if (w){
                        winner = turn;
                        highlightWin(w);
                        statusEl.innerHTML = '胜利: <strong>' + winner + '</strong>';
                        return;
                    }
                    if (board.every(v=>v!==null)){
                        statusEl.textContent = '平局';
                        return;
                    }
                    // switch turn
                    turn = turn === 'X' ? 'O' : 'X';
                    turnEl.textContent = turn;
                    statusEl.innerHTML = '轮到: <strong id="turn">' + turn + '</strong>';
                    // if AI is enabled and it's AI's turn, trigger AI move
                    if (aiEnabled && turn === aiSide && !winner){
                        setTimeout(aiMove, 300);
                    }
                }
            }

            function drawMarkAt(i, symbol){
                const node = nodes[i];
                const cx = parseFloat(node.getAttribute('cx'));
                const cy = parseFloat(node.getAttribute('cy'));
                const g = document.createElementNS('http://www.w3.org/2000/svg','g');
                g.setAttribute('data-i', i);
                g.classList.add('mark');
                if (symbol === 'X'){
                    const l1 = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l1.setAttribute('x1', cx-12); l1.setAttribute('y1', cy-12);
                    l1.setAttribute('x2', cx+12); l1.setAttribute('y2', cy+12);
                    const l2 = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l2.setAttribute('x1', cx+12); l2.setAttribute('y1', cy-12);
                    l2.setAttribute('x2', cx-12); l2.setAttribute('y2', cy+12);
                    g.appendChild(l1); g.appendChild(l2);
                } else {
                    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
                    c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 12);
                    c.setAttribute('fill', 'none');
                    g.appendChild(c);
                }
                marksGroup.appendChild(g);
            }

            function checkWin(){
                for (const line of winLines){
                    const [a,b,c] = line;
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) return line;
                }
                return null;
            }

            // check win on an arbitrary board array (used for AI simulation)
            function checkWinFor(boardArr){
                for (const line of winLines){
                    const [a,b,c] = line;
                    if (boardArr[a] && boardArr[a] === boardArr[b] && boardArr[a] === boardArr[c]) return line;
                }
                return null;
            }

            function highlightWin(line){
                for (const idx of line){
                    const mark = marksGroup.querySelector('[data-i="'+idx+'"]');
                    if (mark) mark.classList.add('win');
                }
            }

            function updateSelectionVisual(){
                // remove previous selection classes
                Array.from(marksGroup.querySelectorAll('.mark')).forEach(m => m.classList.remove('selected'));
                Array.from(document.querySelectorAll('.node-area')).forEach(n => n.classList.remove('possible'));
                if (selected !== null){
                    const sel = marksGroup.querySelector('[data-i="'+selected+'"]');
                    if (sel) sel.classList.add('selected');
                    // highlight possible targets based on line rules
                    const allowed = getAllowedTargets(selected);
                    allowed.forEach(idx=>{
                        const nodeEl = document.querySelector('.node-area[data-index="'+idx+'"]');
                        if (nodeEl) nodeEl.classList.add('possible');
                    });
                }
            }

            function flashInvalid(){
                // briefly flash the board to indicate invalid move
                svg.style.transition = 'transform .06s';
                svg.style.transform = 'translateX(6px)';
                setTimeout(()=>{ svg.style.transform='translateX(-6px)'; }, 60);
                setTimeout(()=>{ svg.style.transform=''; svg.style.transition=''; }, 180);
            }

            // --- AI logic ---
            function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

            function aiMove(){
                if (!aiEnabled || winner) return;
                // simple AI: try win, then block, else random legal move
                const ai = aiSide;
                const human = ai === 'X' ? 'O' : 'X';
                // gather all AI pieces and their allowed targets
                const pieces = [];
                for (let i=0;i<board.length;i++){
                    if (board[i] === ai) pieces.push(i);
                }
                // build possible moves [piece,target]
                const moves = [];
                for (const p of pieces){
                    const targets = getAllowedTargets(p);
                    for (const t of targets) moves.push([p,t]);
                }
                if (moves.length === 0){
                    statusEl.textContent = 'AI 无可走步，跳过';
                    // switch back
                    turn = human;
                    turnEl.textContent = turn;
                    return;
                }

                // try winning move
                for (const [p,t] of moves){
                    const copy = board.slice();
                    copy[p] = null;
                    copy[t] = ai;
                    if (checkWinFor(copy)){
                        performAIMove(p,t);
                        return;
                    }
                }
                // try block opponent immediate win: see if human has winning move now, and try to occupy that target
                const humanThreats = new Set();
                for (let hp=0; hp<board.length; hp++){
                    if (board[hp] !== human) continue;
                    const ht = getAllowedTargets(hp);
                    for (const t of ht){
                        const copy = board.slice();
                        copy[hp] = null;
                        copy[t] = human;
                        if (checkWinFor(copy)) humanThreats.add(t);
                    }
                }
                if (humanThreats.size){
                    // try to move to any threatened target
                    for (const [p,t] of moves){
                        if (humanThreats.has(t)){
                            performAIMove(p,t);
                            return;
                        }
                    }
                }
                // fallback: random move among moves
                const [p,t] = pickRandom(moves);
                performAIMove(p,t);
            }

            function performAIMove(p,t){
                // small delay to show thinking
                svg.style.pointerEvents = 'none';
                statusEl.textContent = 'AI 思考中...';
                setTimeout(()=>{
                    board[p] = null;
                    board[t] = aiSide;
                    drawAllMarks();
                    const w = checkWin();
                    if (w){
                        winner = aiSide;
                        highlightWin(w);
                        statusEl.innerHTML = '胜利: <strong>' + winner + '</strong>';
                    } else {
                        // switch turn back to human
                        turn = turn === 'X' ? 'O' : 'X';
                        turnEl.textContent = turn;
                        statusEl.innerHTML = '轮到: <strong id="turn">' + turn + '</strong>';
                    }
                    svg.style.pointerEvents = '';
                }, 420);
            }

            aiBtn.addEventListener('click', ()=>{
                aiEnabled = !aiEnabled;
                aiBtn.textContent = 'AI: ' + (aiEnabled ? '开' : '关');
                // if enabling and it's AI's turn, trigger move
                if (aiEnabled && turn === aiSide && !winner){
                    setTimeout(aiMove, 300);
                }
            });
            // --- Online multiplayer via WebSocket ---
            const onlineBtn = document.createElement('button');
            onlineBtn.id = 'onlineBtn';
            onlineBtn.className = 'btn';
            onlineBtn.textContent = '在线: 关';
            document.querySelector('.controls').appendChild(onlineBtn);

            let ws = null;
            let onlineRoom = null;
            let onlineSide = null;
            function connectOnline(){
                const url = prompt('输入 WebSocket 服务器地址（例如 ws://localhost:3000 或 ws://yourdomain:3000）', window.location.hostname === 'localhost' ? 'ws://localhost:3000' : ('wss://' + window.location.host));
                if (!url) return;
                ws = new WebSocket(url);
                ws.addEventListener('open', ()=> {
                    onlineBtn.textContent = '在线: 匹配中';
                    ws.send(JSON.stringify({ type:'join' }));
                });
                ws.addEventListener('message', (ev)=>{
                    const d = JSON.parse(ev.data);
                    if (d.type === 'queued') {
                        statusEl.textContent = '已排队，等待对手...';
                    } else if (d.type === 'start'){
                        onlineRoom = d.room;
                        onlineSide = d.side;
                        // set board to server board
                        for (let i=0;i<9;i++) board[i] = d.board[i];
                        drawAllMarks();
                        turn = d.turn;
                        turnEl.textContent = turn;
                        onlineBtn.textContent = '在线: 已连接';
                        statusEl.textContent = '已连上对手，您是 ' + onlineSide;
                    } else if (d.type === 'opponent_move'){
                        // apply opponent move
                        const side = d.side;
                        board[d.from] = null;
                        board[d.to] = side;
                        drawAllMarks();
                        turn = (side === 'X') ? 'O' : 'X';
                        turnEl.textContent = turn;
                    } else if (d.type === 'turn'){
                        turn = d.turn;
                        turnEl.textContent = turn;
                    } else if (d.type === 'game_over'){
                        winner = d.winner;
                        highlightWin(d.line);
                        statusEl.innerHTML = '胜利: <strong>' + winner + '</strong>';
                    } else if (d.type === 'opponent_left'){
                        statusEl.textContent = '对手已离开';
                        onlineBtn.textContent = '在线: 离线';
                    } else if (d.type === 'error'){
                        console.warn('server error', d);
                    }
                });
                ws.addEventListener('close', ()=> {
                    statusEl.textContent = '与服务器断开连接';
                    onlineBtn.textContent = '在线: 关';
                    ws = null;
                    onlineRoom = null;
                    onlineSide = null;
                });
            }
            onlineBtn.addEventListener('click', ()=>{
                if (!ws){
                    connectOnline();
                } else {
                    try { ws.send(JSON.stringify({ type:'leave' })); ws.close(); } catch(e){}
                }
            });

            // override local move sending when online
            const originalHandleNodeClick = handleNodeClick;
            function handleNodeClickOnline(i){
                if (!ws || !onlineRoom || !onlineSide) {
                    originalHandleNodeClick(i);
                    return;
                }
                // only allow selecting/moving your side
                const cell = board[i];
                if (cell === onlineSide){
                    // select/deselect locally (same UI)
                    if (selected === i) selected = null; else selected = i;
                    updateSelectionVisual();
                    return;
                }
                if (cell === null && selected !== null){
                    const allowed = getAllowedTargets(selected);
                    if (!allowed.includes(i)) { flashInvalid(); return; }
                    // send move to server
                    ws.send(JSON.stringify({ type:'move', room: onlineRoom, from: selected, to: i }));
                }
            }
            // swap event listeners to use online-aware handler
            nodes.forEach((n, idx) => {
                n.replaceWith(n.cloneNode(true));
            });
            // re-query nodes and rebind with online-aware click
            const newNodes = Array.from(document.querySelectorAll('.node-area'));
            newNodes.forEach(n => n.addEventListener('click', ()=> handleNodeClickOnline(parseInt(n.getAttribute('data-index'),10))));
            // color pickers for accent (米字线) and primary (highlights)
            const accentPicker = document.getElementById('accentPicker');
            const primaryPicker = document.getElementById('primaryPicker');
            function hexToRgb(hex){
                const h = hex.replace('#','');
                return [parseInt(h.substring(0,2),16), parseInt(h.substring(2,4),16), parseInt(h.substring(4,6),16)];
            }
            function setCSSVar(name, value){ document.documentElement.style.setProperty(name, value); }
            // initialize pickers from current CSS variables or defaults
            const rootStyle = getComputedStyle(document.documentElement);
            const currentAccent = rootStyle.getPropertyValue('--accent').trim() || '#e53935';
            const currentPrimary = rootStyle.getPropertyValue('--primary').trim() || '#1e88ff';
            accentPicker.value = currentAccent;
            primaryPicker.value = currentPrimary;
            accentPicker.addEventListener('input', (e)=>{
                const v = e.target.value;
                setCSSVar('--accent', v);
            });
            primaryPicker.addEventListener('input', (e)=>{
                const v = e.target.value;
                setCSSVar('--primary', v);
                // also update mark circle stroke to match primary
                document.querySelectorAll('.mark circle').forEach(c => c.setAttribute('stroke', v));
            });
            // persist choices
            [accentPicker, primaryPicker].forEach(inp => {
                inp.addEventListener('change', ()=>{
                    localStorage.setItem('mi_accent', accentPicker.value);
                    localStorage.setItem('mi_primary', primaryPicker.value);
                });
            });
            // load persisted
            const savedAccent = localStorage.getItem('mi_accent');
            const savedPrimary = localStorage.getItem('mi_primary');
            if (savedAccent) { accentPicker.value = savedAccent; setCSSVar('--accent', savedAccent); }
            if (savedPrimary) { primaryPicker.value = savedPrimary; setCSSVar('--primary', savedPrimary); document.querySelectorAll('.mark circle').forEach(c => c.setAttribute('stroke', savedPrimary)); }

            function reset(){
                // restore initial configuration: top row X, bottom row O
                for (let i=0;i<9;i++) board[i] = initialBoard[i];
                turn = 'X';
                winner = null;
                selected = null;
                turnEl.textContent = turn;
                statusEl.innerHTML = '轮到: <strong id="turn">X</strong>';
                drawAllMarks();
                if (aiEnabled && turn === aiSide){
                    setTimeout(aiMove, 300);
                }
            }

            // initialize
            nodes.forEach(n=> n.addEventListener('click', ()=> handleNodeClick(parseInt(n.getAttribute('data-index'),10))));
            resetBtn.addEventListener('click', reset);
            drawAllMarks();
            // call mobile adjust once after draw
            adjustForMobile();

            window.miGame = { board, reset };
        })();
    </script>
</body>

</html>